<h1>Разбор задач летнего отбора в параллель A Яндекс Кружка</h1><br>Автор статьи: tiom4eg

<h2>Задача A'-A 1</h2>
<details>
  <summary>Подсказка 1</summary>

  Давайте вспомним про выпуклые оболочки. Как они могут помочь при решении этой задачи?
  
</details>
<details>
  <summary>Полное решение</summary>

  Определения и обозначения:

  Многоугольник из условия будем обозначать как $P$.
  
  Пусть есть множество точек $S$, лежащих на одной прямой $l$.
  *Крайней* будем называть такую $p \in S$, что все точки в $S \setminus p$ лежат по одну сторону от перпендикуляра к $l$, проведённого через $p$.
  
  <br>
  
  Решение:

  Эту задачу наверняка можно было решать несколькими способами, но здесь рассмотрим конкретно моё решение.

  Для начала заметим, что если для какой-то прямой $l$, содержащей две точки $P$, все точки $P$ находятся в одной полуплоскости, то $l$ будет содержать в себе какую-то сторону выпуклой оболочки $P$.
  Могут быть случаи, когда на $l$ лежит больше двух вершин $P$, однако тогда в выпуклую оболочку будут входить только две *крайние* вершины $P$ из множества тех, что лежат на $l$.
  В таком случае, если для каких-то двух вершин, лежащих на $l$, проекция центра масс будет лежать на отрезке между ними, то она точно будет лежать на отрезке между двумя *крайними* для этой прямой вершинами.

  Значит, для решения задачи нам достаточно построить выпуклую оболочку $P$ и посчитать количество соседних пар вершин в ней, для которых выполняется условие.
  
</details>

<h2>Задача A'-A 2</h2>
<details>
  <summary>Подсказка 0</summary>

  Это не задача на структуры данных.
  
</details>
<details>
  <summary>Подсказка 1</summary>

  Пусть $(l, r)$ - это такое состояние в задаче, что последней посещённой вершиной на левом берегу была $l$, а на правом $r$. 
  По условию из $(l, r)$ можно перейти только в $(x, r)$ и $(l, y)$, где $l \lt x$ и $r \lt y$, следовательно, граф состояний ацикличен.
  
</details>
<details>
  <summary>Полное решение</summary>

  Определения и обозначения:

  $(l, r)$ - это такое состояние в задаче, что последней посещённой вершиной на левом берегу была $l$, а на правом $r$. 
  
  $g_i$ - отсортированный список вершин, в которые ведут рёбра из вершины $i$.
  
  <br>
  
  Решение:

  Как было сказано в подсказке 1, если рассматривать граф состояний в данной задаче, то он будет ацикличным. Вспоминаем, что на ацикличных графах можно подсчитывать динамику с мемоизацией.

  Пусть мы находимся в состоянии $(l, r)$, причём сейчас мы стоим в вершине $l$ левого берега (для вершины $r$ правого берега аналогично). 
  Тогда можно заметить, что текущее состояние можно пересчитать через все состояния $(l, x)$, где $x \in g_l$ и $x \gt r$.

  Далее можно заметить, что для вершины $l$ левого берега достаточно сосчитать только такие состояния $(l, x)$, что $x \in g_l$, а для всех оставшихся $x$ соответствующее состояние находится `lower_bound`-ом по $g_l$.
  Значит, всего состояний динамики будет $O(p)$, а её пересчёт займет $O(p \cdot log (n + m))$.
  
</details>

<h2>Задача A'-A 3</h2>
<details>
  <summary>Подсказка 0</summary>

  Эта задача решается без техники разделяй-и-властвуй.
  
</details>
<details>
  <summary>Подсказка 1</summary>

  Стоимость отрезков с общей границей можно поддерживать при помощи стека минимумов и максимумов.
  
</details>
<details>
  <summary>Полное решение</summary>

  Определения и обозначения:

  $cost(l, r)$ - красота подотрезка $[l; r]$.

  $dp_i$ - сумма привлекательностей всех разбиений префикса $[0; i]$ на подотрезки.
  
  <br>
  
  Решение:

  Заметим, что $$dp_i = \sum_{j=0}^{i - 1} dp_j \cdot cost(j + 1, i)$$

  Будем поддерживать стек минимумов и максимумов, причём помимо самих значений будем также хранить сумму значений динамики на отрезке от первой до последней позиции с соответствующим минимумом/максимумом. 
  При добавлении нового элемента (подсчет $dp_i$ через предыдущие значения) достаточно будет обновить стек минимумов/максимумов.

  Получаем решение за амортизированное $O(n)$.
  
</details>

<h2>Задача A'-A 4</h2>
<details>
  <summary>Подсказка 0</summary>

  Эта задача - конструктив :)
  
</details>
<details>
  <summary>Подсказка 1</summary>

  Хочется покрасить клетки так, чтобы у любой не-крайней клетки был сосед каждого цвета, а также чтобы каждая клетка была покрашена не более чем одним цветом.
  
</details>
<details>
  <summary>Полное решение</summary>
  
  Пусть изначально красными клетками будут такие $(x, y)$, что либо $y$ нечётно, либо $x = n - 2$. То есть, изначально красные клетки будут создавать связную "расчёску", а все остальные клетки будут зелёными и также будут образовывать связную область.

  Теперь заметим, что для любого $(x, y)$ при $1 \leq x \leq n - 2, 1 \leq y \leq m - 2$, клетка $(x, y)$ будет иметь как красного, так и зелёного соседа, а значит, что если эту клетку надо покрасить в жёлтый цвет, то мы докрашиваем её в недостающий цвет, сохраняя связность обеих областей.
  
</details>

<h2>Задача A'-A 5</h2>
<details>
  <summary>Подсказка 1</summary>

  Заметим, что запрос типа 1 на префиксе массива, отсортированного по невозрастанию, сохраняет массив отсортированным по невозрастанию.
  
</details>
<details>
  <summary>Подсказка 2</summary>

  Для любого запроса типа 2 все дни, в которые будут решаться задачи, будут образовывать небольшое количество отрезков из подряд идущих тренировочных дней. Почему?
  
</details>
<details>
  <summary>Полное решение</summary>
  
  На самом деле, запрос типа 1 при заданных ограничениях эквивалентен запросу присваивания на отрезке: ищем первый элемент массива, меньший $x$, и присваиваем всем элементам начиная с него и до позиции $k$ значение $x$.

  Теперь докажем утверждение, написанное в подсказке 2. Действительно, пусть есть такое $p$, что $a_p \leq x$. Будем вычитать $a_p$ из $x$ и переходить к следующему элементу до тех пор, пока не наткнемся на такое $q$, что $a_q \gt x$.
  Обозначим значение $x$ до вычитания суммы отрезка $[p; q)$ как $x_0$. В таком случае, $x_0 \geq x + a_p, a_p \geq a_q \gt x \implies x_0 \gt 2x$, то есть после рассмотрения очередного отрезка $x$ уменьшается хотя бы в $2$ раза, а значит, всего будет рассмотрено не более $O(log C)$ отрезков.

  Все вышеописанные запросы можно выполнять с помощью дерева отрезков: запрос типа 1 тривиален, запрос типа 2 можно делать техникой спуска по дереву отрезков за $O(log n)$.

  Асимптотика решения: $O(n \cdot log n \cdot log C)$, чего достаточно при ограничениях задачи.
  
</details>

<h2>Задача A'-A 6 (TODO)</h2>
<details>
  <summary>Подсказка 1</summary>

  TODO
  
</details>
<details>
  <summary>Подсказка 2</summary>

  TODO
  
</details>
<details>
  <summary>Полное решение</summary>
  
  TODO
  
</details>

<h2>Задача A 1</h2>
<details>
  <summary>Подсказка 1</summary>

  Используем модификацию ретроанализа, чтобы определить, можно ли при правильной игре обоих игроков завершить прогулку.
  
</details>
<details>
  <summary>Подсказка 2</summary>

  Предположим, что прогулку можно завершить, осталось найти длину искомого пути в достаточно нестандартном графе. Однако, это легче, чем может показаться.
  
</details>
<details>
  <summary>Полное решение</summary>
  
  Определения и обозначения:

  $g_i$ - список вершин, ИЗ КОТОРЫХ ведут рёбра В вершину $i$.

  *Терминальной* будем называть вершину, у которой нет исходящих рёбер.
  
  <br>
  
  Решение:

  Разделим каждую вершину исходного графа на две копии - одна будет обозначать состояние, при котором ход из этой вершины делает игрок 1, другая - при котором ход делает игрок 2. Если в исходном графе было ребро $(u, v)$, то в получившемся будут рёбра $(u1, v2)$ и $(u2, v1)$.

  Далее нам нужно узнать, существует ли путь из стартовой вершины в любую из *терминальных*. Для этого будем поддерживать в очереди вершины, для которых существует путь в *терминальную* вершину. 
  Рассматривая очередную вершину $v$, обойдём все $u \in g_v$. Если $u$ - вершина первого игрока, то мы нашли какой-то путь из неё в *терминальную* вершину, а поскольку первый игрок стремится закончить прогулку - ему будет достаточно и этого.
  Если же $u$ - вершина второго игрока, то из неё существует путь в *терминальную* вершину только в том случае, сли он существует и для любой $w \in g_u$.
  
  Если из стартовой вершины существует путь в *терминальную*, нам нужно найти оптимальный для обоих игроков.
  Будем делать это, поддерживая в приоритетной очереди все *уверенные* вершины первого игрока, т.е. те, для которых мы точно знаем оптимальную длину пути.

  Изначально *уверенными* будут только *терминальные* вершины, далее на каждом шагу будем брать из очереди вершину $v$ с наименьшей длиной пути. Если оказалось, что делая $v$ *уверенной*, для какой-то $u \in g_v$ все её соседи становятся *уверенными*, мы можем посчитать оптимальное значение в $u$ и обновить им все $w \in g_u$. Нетрудно доказать, что такой алгоритм будет учитывать только те пути, которые оптимальны для обоих игроков.

  Мы смогли посчитать оптимальный для обоих игроков путь из каждой вершины, а значит узнали ответ на задачу.
  
</details>
